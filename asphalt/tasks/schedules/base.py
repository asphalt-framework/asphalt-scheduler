from abc import ABCMeta, abstractmethod
from datetime import datetime
from numbers import Real
from typing import Optional, Dict, Any, Union, Iterable
from uuid import uuid4

import pytz
from typeguard import check_argument_types

from asphalt.tasks.util import as_timezone, T_PYTZ


class BaseSchedule(metaclass=ABCMeta):
    """
    Abstract base class for task schedules.

    :ivar str id: unique identifier of this schedule (autogenerated if omitted)
    :ivar str task_id: unique identifier of the scheduled task
    :ivar tuple args: positional arguments to call the task with
    :ivar Dict[str, Any] kwargs: keyword arguments to call the task with
    :ivar Real misfire_grace_time: the time (in seconds) how much this task's execution is allowed
        to be late (omit to use the global default)
    """

    __slots__ = 'id', 'timezone', 'task_id', 'args', 'kwargs', 'misfire_grace_time'

    def __init__(self, task_id: str, timezone: Union[T_PYTZ, str], *, id: str = None,
                 args: Union[tuple, list] = (), kwargs: Dict[str, Any] = None,
                 misfire_grace_time: Real = None):
        assert check_argument_types()
        if misfire_grace_time is not None and misfire_grace_time <= 0:
            raise ValueError('misfire_grace_time must be a positive integer or None')

        self.task_id = task_id
        self.timezone = as_timezone(timezone)
        self.id = id or uuid4().hex
        self.args = tuple(args)
        self.kwargs = kwargs or {}
        self.misfire_grace_time = misfire_grace_time

    @abstractmethod
    def get_next_run_time(self, now: datetime,
                          previous_run_time: datetime = None) -> Optional[datetime]:
        """
        Calculate the next time when the task should be run.

        If a datetime value is returned, it **MUST** be later than ``previous_run_time`` to prevent
        infinite loops.

        :param now: the current time (timezone aware)
        :param previous_run_time: time of the previous run (timezone aware) or ``None``
        :return: a timezone-aware datetime, or ``None`` if no next run time can be calculated
        """

    def get_run_times(self, now: datetime, previous_run_time: datetime) -> Iterable[datetime]:
        """
        Compute the scheduled run times between ``previous_run_time`` and ``now``.

        :param now: the current time (timezone aware)
        :param previous_run_time: time of the previous run (timezone aware)
        :return: an iterable of run times up to and including ``now``

        """
        while True:
            previous_run_time = self.get_next_run_time(now, previous_run_time)
            if previous_run_time and previous_run_time <= now:
                yield previous_run_time
            else:
                break

    @abstractmethod
    def __getstate__(self) -> Dict[str, Any]:
        state = {
            'id': self.id,
            'task_id': self.task_id,
            'timezone': self.timezone.zone,
            'misfire_grace_time': self.misfire_grace_time
        }
        if self.args:
            state['args'] = self.args
        if self.kwargs:
            state['kwargs'] = self.kwargs

        return state

    @abstractmethod
    def __setstate__(self, state: Dict[str, Any]) -> None:
        self.id = state['id']
        self.task_id = state['task_id']
        self.timezone = pytz.timezone(state['timezone'])
        self.args = tuple(state.get('args', ()))
        self.kwargs = state.get('kwargs', {})
        self.misfire_grace_time = state['misfire_grace_time']
